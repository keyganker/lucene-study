// QueryParser.jj
// Copyright (c) 1997, 2000 Douglass R. Cutting.

options {
  USER_TOKEN_MANAGER = true;
  USER_CHAR_STREAM = true;
  STATIC= false;
}

PARSER_BEGIN(QueryParser)

package com.lucene.queryParser;

import java.util.Vector;
import com.lucene.index.Term;
import com.lucene.analysis.Analyzer;
import com.lucene.analysis.TokenStream;
import com.lucene.search.Query;
import com.lucene.search.TermQuery;
import com.lucene.search.BooleanQuery;
import com.lucene.search.BooleanClause;
import com.lucene.search.PhraseQuery;

/**
 * This class is generated by JavaCC.  The only method that clients should need
 * to call is <a href="#parse">parse()</a>.
 *
 * The syntax for query strings is as follows:
 * A Query is a series of clauses.
 * A clause may be prefixed by: 
 * <ul>
 * <li> a plus (<code>+</code>) or a minus (<code>-</code>) sign, indicating
 * that the clause is required or prohibited respectively; or
 * <li> a term followed by a colon, indicating the field to be searched.
 * This enables one to construct queries which search multiple fields.
 * </ul>
 *
 * A clause may be either a:
 * <ul>
 * <li> a term, indicating all the documents that contain this term; or
 * <li> a nested query, enclosed in parentheses.  Note that this may be used
 * with a <code>+</code>/<code>-</code> prefix to require any of a set of
 * terms.
 * </ul>
 *
 * Thus, in BNF, the query grammar is:
 * <pre>
 *   Query  ::= ( Clause )*
 *   Clause ::= ["+", "-"] [<TERM> ":"] ( <TERM> | "(" Query ")" )
 * </pre>
 */

public class QueryParser {
  /** Parses a query string, returning a
   * <a href="lucene.search.Query.html">Query</a>.
   *  @param query	the query string to be parsed.
   *  @param field	the default field for query terms.
   *  @param analyzer   used to find terms in the query text.
   */
  static public Query parse(String query, String field, Analyzer analyzer)
       throws ParseException {
    TokenManager tm = new QueryTokenManager(query, analyzer);
    QueryParser parser = new QueryParser(tm);
    return parser.Query(field);
  }
       
  Analyzer analyzer;
  String field;
  int phraseSlop = 0;

  /** Constructs a query parser.
   *  @param field	the default field for query terms.
   *  @param analyzer   used to find terms in the query text.
   */
  public QueryParser(String f, Analyzer a) {
    analyzer = a;
    field = f;
  }

  /** Parses a query string, returning a
   * <a href="lucene.search.Query.html">Query</a>.
   *  @param query	the query string to be parsed.
   */
  public Query parse(String query) throws ParseException {
    ReInit(new QueryTokenManager(query, analyzer));
    return Query(field);
  }

  /** Sets the default slop for phrases.  If zero, then exact phrase matches
    are required.  Zero by default. */
  public void setPhraseSlop(int s) { phraseSlop = s; }
  /** Gets the default slop for phrases. */
  public int getPhraseSlop() { return phraseSlop; }

}

PARSER_END(QueryParser)

Query Query(String field) :
{
  Vector clauses = new Vector();
}
{
 (
   {
     boolean required = false, prohibited = false, and = false;
     Query subQuery;
   }
   
   [
     <PLUS>  { required = true; }
   |
     <MINUS> { prohibited = true; }
   |
   LOOKAHEAD(2)
     <AND> <NOT> { and = true; prohibited = true; }
   |
     <AND>   { and = true; required = true; }
   |
     <NOT>   { prohibited = true; }
   |
     <OR>
   ]

   subQuery = subQuery(field)

   {
     if (and) {
       if (clauses.size() == 0)		  // find previous clause
	 throw new ParseException("Query can't start with AND.");
       BooleanClause clause =
	 (BooleanClause)clauses.elementAt(clauses.size() - 1);
       clause.required = true;			  // require it
     }
     clauses.addElement(new BooleanClause(subQuery, required, prohibited));
   }
 )*
    {
      BooleanQuery query = new BooleanQuery();
      for (int i = 0; i < clauses.size(); i++)
	query.add((BooleanClause)clauses.elementAt(i));
      return query;
    }
}

Query subQuery(String field) :
{
  Query subQuery;
  Token fieldToken;
}
{
  [
   LOOKAHEAD(3)
   fieldToken=<TERM>
   <COLON> { field = fieldToken.image; }
  ]

  (
   subQuery = Term(field)
   | <QUOTE> subQuery = Phrase(field) <QUOTE>
   | <OPEN> subQuery = Query(field) <CLOSE>
  )
    {
      return subQuery;
    }
}
    


TermQuery Term(String field) :
{ Token term; }
{
  term=<TERM>
    { return new TermQuery(new Term(field, term.image)); }
}


PhraseQuery Phrase(String field) :
{
  PhraseQuery phrase = new PhraseQuery();
  phrase.setSlop(phraseSlop);
  Token term;
}
{
  ( term=<TERM>
    { phrase.add(new Term(field, term.image)); }
  )*
    { return phrase; }
}
